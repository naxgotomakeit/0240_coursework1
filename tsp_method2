#!/usr/bin/env python3

# ==============================================================================
# MASTER'S NOTE: Method 2 - Environment-Aware TSP (Visibility Graph Detour + Z-Elevator)
# Date Authored: 2026-01-06
# Description: This advanced system uses a 3D bounding box vertex heuristic to 
#              generate collision-free detours. If blocked by complex connected
#              obstacles, it dynamically activates a Z-axis fly-over strategy.
#              (Note: Total Mission Time excludes landing physical delay for fair metric)
# ==============================================================================

import argparse
from time import sleep
import time
import yaml
import numpy as np

# å¯¼å…¥ TSP æ±‚è§£å™¨
from python_tsp.heuristics import solve_tsp_local_search
from as2_python_api.drone_interface import DroneInterface
import rclpy

TAKE_OFF_HEIGHT = 1.0  
TAKE_OFF_SPEED = 1.0  
SLEEP_TIME = 0.5  
SPEED = 1.0  
LAND_SPEED = 0.5  

# ==========================================================
# ðŸ§  å¤§è„‘æ¨¡å—ï¼šå‡ ä½•å¯è§†å›¾ä¸ŽçœŸå®žä»£ä»·æŽ¨æ¼”
# ==========================================================

def extract_bounds(obstacles_dict):
    bounds = []
    if not obstacles_dict: return bounds
    for obs_id, obs in obstacles_dict.items():
        half_w, half_d, half_h = obs['w'] / 2.0, obs['d'] / 2.0, obs['h'] / 2.0
        # å®‰å…¨è†¨èƒ€ç³»æ•° 0.5ï¼Œå½»åº•é˜²æ­¢è½¬å¼¯æ¼‚ç§»è¹­å¢™
        min_b = np.array([obs['x'] - half_w, obs['y'] - half_d, obs['z'] - half_h]) - 0.5
        max_b = np.array([obs['x'] + half_w, obs['y'] + half_d, obs['z'] + half_h]) + 0.5
        bounds.append((min_b, max_b))
    return bounds

def check_collision(p1, p2, obstacle_bounds, num_samples=50):
    if not obstacle_bounds: return False
    t = np.linspace(0, 1, num_samples)[:, np.newaxis] 
    segment_points = p1 + t * (p2 - p1)
    for min_b, max_b in obstacle_bounds:
        inside_x = (segment_points[:, 0] >= min_b[0]) & (segment_points[:, 0] <= max_b[0])
        inside_y = (segment_points[:, 1] >= min_b[1]) & (segment_points[:, 1] <= max_b[1])
        inside_z = (segment_points[:, 2] >= min_b[2]) & (segment_points[:, 2] <= max_b[2])
        if np.any(inside_x & inside_y & inside_z): return True 
    return False

def get_inflated_vertices(obs):
    """èŽ·å–éšœç¢ç‰©è†¨èƒ€ 0.5m åŽçš„ 8 ä¸ªå®‰å…¨é¡¶ç‚¹åæ ‡ (é¿éšœè·³æ¿)"""
    half_w, half_d, half_h = obs['w'] / 2.0, obs['d'] / 2.0, obs['h'] / 2.0
    min_x, max_x = obs['x'] - half_w - 0.5, obs['x'] + half_w + 0.5
    min_y, max_y = obs['y'] - half_d - 0.5, obs['y'] + half_d + 0.5
    min_z, max_z = obs['z'] - half_h - 0.5, obs['z'] + half_h + 0.5
    
    vertices = []
    for x in (min_x, max_x):
        for y in (min_y, max_y):
            for z in (min_z, max_z):
                vertices.append(np.array([x, y, z]))
    return vertices

def calculate_shortest_detour(p1, p2, obstacle_bounds, all_obstacles_dict):
    """
    å®Œå…¨ä½“ç»•è¡Œå¤§è„‘ï¼š
    ä¼˜å…ˆå°è¯• 2D ä¾§è¾¹ç»•è¡Œï¼ˆçœç”µï¼‰ï¼Œå¦‚æžœé‡åˆ°è¿žä½“éšœç¢ç‰©è¢«æ­»æ­»æŒ¡ä½ï¼Œ
    è‡ªåŠ¨è§¦å‘ 3D Zè½´å‡ç»´è·¨è¶Šï¼ˆé£žè¶Šæœ€é«˜ç‚¹ï¼‰ï¼
    """
    best_distance = float('inf')
    best_waypoints = None 
    
    if not all_obstacles_dict: 
        return best_distance, best_waypoints
        
    # --- ç­–ç•¥ 1ï¼šä¾§è¾¹å•é¡¶ç‚¹ç»•è¡Œ (V-shape Detour) ---
    for obs_id, obs in all_obstacles_dict.items():
        vertices = get_inflated_vertices(obs)
        for v in vertices:
            if not check_collision(p1, v, obstacle_bounds) and \
               not check_collision(v, p2, obstacle_bounds):
                dist = np.linalg.norm(p1 - v) + np.linalg.norm(v - p2)
                if dist < best_distance:
                    best_distance = dist
                    best_waypoints = [v]
                    
    # --- ç­–ç•¥ 2ï¼šå¦‚æžœä¾§è¾¹å…¨è¢«æŒ¡æ­»ï¼Œå¯åŠ¨â€œå‡ç»´ç”µæ¢¯â€é£žè¶Šç­–ç•¥ï¼ ---
    if best_waypoints is None:
        max_z = -float('inf')
        for obs_id, obs in all_obstacles_dict.items():
            peak = obs['z'] + (obs['h'] / 2.0)
            if peak > max_z: 
                max_z = peak
                
        safe_z = max_z + 0.5 
        
        wp1 = np.array([p1[0], p1[1], safe_z])
        wp2 = np.array([p2[0], p2[1], safe_z])
        
        if not check_collision(p1, wp1, obstacle_bounds) and \
           not check_collision(wp1, wp2, obstacle_bounds) and \
           not check_collision(wp2, p2, obstacle_bounds):
            
            dist = np.linalg.norm(p1 - wp1) + np.linalg.norm(wp1 - wp2) + np.linalg.norm(wp2 - p2)
            best_distance = dist
            best_waypoints = [wp1, wp2]

    return best_distance, best_waypoints

def build_cost_matrix(scenario_data):
    """æž„å»ºçœŸå®žçš„ N x N ç‰©ç†ä»£ä»·çŸ©é˜µï¼Œå¹¶è®°å½•é¿éšœè·¯ç‚¹"""
    points = []
    start_pose = scenario_data['drone_start_pose']
    points.append([start_pose['x'], start_pose['y'], start_pose['z']])
    
    vp_poses = scenario_data['viewpoint_poses']
    vp_ids = sorted(vp_poses.keys()) 
    for vp_id in vp_ids:
        vp = vp_poses[vp_id]
        points.append([vp['x'], vp['y'], vp['z']])
        
    points_array = np.array(points)
    N = len(points_array)
    obstacles_dict = scenario_data.get('obstacles', {})
    obstacle_bounds = extract_bounds(obstacles_dict)
    
    cost_matrix = np.zeros((N, N))
    waypoints_matrix = {}
    
    for i in range(N):
        for j in range(N):
            if i == j: continue
            straight_dist = np.linalg.norm(points_array[i] - points_array[j])
            
            if check_collision(points_array[i], points_array[j], obstacle_bounds):
                detour_dist, waypoint_list = calculate_shortest_detour(
                    points_array[i], points_array[j], obstacle_bounds, obstacles_dict
                )
                if waypoint_list is not None:
                    cost_matrix[i][j] = detour_dist
                    waypoints_matrix[(i, j)] = waypoint_list 
                else:
                    cost_matrix[i][j] = straight_dist * 100.0 
            else:
                cost_matrix[i][j] = straight_dist
                
    return cost_matrix, vp_ids, points_array, waypoints_matrix


# ==========================================================
# ðŸš ç‰©ç†æ‰§è¡Œæ¨¡å—ï¼šæºå¸¦â€œå‰§æœ¬â€çš„æ™ºèƒ½é£žè¡Œ
# ==========================================================

def drone_start(drone_interface: DroneInterface) -> bool:
    print('[LOG] ðŸ›« Start mission sequence...')
    success = drone_interface.arm()
    success = success and drone_interface.offboard()
    success = success and drone_interface.takeoff(height=TAKE_OFF_HEIGHT, speed=TAKE_OFF_SPEED)
    return success

def drone_run(drone_interface: DroneInterface, scenario: dict, metrics: dict) -> bool:
    print('\n[LOG] === ðŸ§  PHASE 1: ENVIRONMENT-AWARE PLANNING ===')
    
    start_algo_time = time.time()
    matrix, original_vp_ids, points_array, waypoints_matrix = build_cost_matrix(scenario)
    route_indices, _ = solve_tsp_local_search(matrix)
    algo_time = time.time() - start_algo_time
    
    planned_distance = 0.0
    optimized_vpids = []

    print(f'[LOG] Algorithm Computation Time: {algo_time:.4f} seconds')
    print('\n[LOG] === ðŸš PHASE 2: TACTICAL EXECUTION ===')
    
    for step in range(len(route_indices) - 1):
        idx_current = route_indices[step]
        idx_next = route_indices[step + 1]
        
        vpid = original_vp_ids[idx_next - 1]
        vp = scenario["viewpoint_poses"][vpid]
        optimized_vpids.append(vpid)
        goal = [vp["x"], vp["y"], vp["z"]]
        
        if (idx_current, idx_next) in waypoints_matrix:
            wp_list = waypoints_matrix[(idx_current, idx_next)]
            current_pos = points_array[idx_current]
            
            for wp in wp_list:
                planned_distance += np.linalg.norm(current_pos - wp)
                print(f'[LOG] âš ï¸ Executing tactical waypoint: [x={wp[0]:.2f}, y={wp[1]:.2f}, z={wp[2]:.2f}]')
                
                success = drone_interface.go_to.go_to_point_with_yaw([float(wp[0]), float(wp[1]), float(wp[2])], angle=vp["w"], speed=SPEED * 0.8)
                if not success: return False
                current_pos = wp
                
            planned_distance += np.linalg.norm(current_pos - points_array[idx_next])
            
        else:
            planned_distance += np.linalg.norm(points_array[idx_current] - points_array[idx_next])

        print(f'[LOG] >>> Proceeding to Target Viewpoint {vpid} (Pose: x={vp["x"]:.2f}, y={vp["y"]:.2f}, yaw={vp["w"]:.2f})')
        success = drone_interface.go_to.go_to_point_with_yaw(goal, angle=vp["w"], speed=SPEED)
        
        if not success:
            print(f'[ERROR] âŒ Failed to reach Viewpoint {vpid}!')
            return False
            
        print(f'[LOG] âœ… Reached Viewpoint {vpid}. (Simulating Camera Trigger...)')
        sleep(SLEEP_TIME)

    metrics['algo_time'] = algo_time
    metrics['planned_distance'] = planned_distance
    metrics['visit_order'] = optimized_vpids

    return True

def drone_end(drone_interface: DroneInterface) -> bool:
    print('\n[LOG] ðŸ›¬ Ending mission (Landing sequence initiated)...')
    success = drone_interface.land(speed=LAND_SPEED)
    success = success and drone_interface.manual()
    return success

def read_scenario(file_path):
    with open(file_path, 'r') as file:
        scenario = yaml.safe_load(file)
    return scenario

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Method 2: Environment-Aware TSP (Ultimate)')
    parser.add_argument('scenario', type=str, help="scenario file")
    parser.add_argument('-n', '--namespace', type=str, default='drone0')
    parser.add_argument('-v', '--verbose', action='store_true', default=False)
    parser.add_argument('-s', '--use_sim_time', action='store_true', default=True)

    args = parser.parse_args()
    scenario = read_scenario(args.scenario)
    rclpy.init()

    uav = DroneInterface(drone_id=args.namespace, use_sim_time=args.use_sim_time, verbose=args.verbose)
    
    mission_metrics = {'algo_time': 0.0, 'planned_distance': 0.0, 'visit_order': [], 'mission_success': False, 'total_time': 0.0}
    start_total_time = time.time()
    
    success = drone_start(uav)
    try:
        if success:
            flight_success = drone_run(uav, scenario, mission_metrics)
            mission_metrics['mission_success'] = flight_success
            
            # ã€æ ¸å¿ƒä¿®æ”¹ç‚¹ã€‘ï¼šåœ¨æ‰“å¡å®Œæœ€åŽä¸€ä¸ªç›®æ ‡ç‚¹åŽï¼Œç«‹å³åœæ­¢è®¡æ—¶ï¼ä¸è®¡å…¥é™è½çš„ç‰©ç†å»¶è¿Ÿã€‚
            mission_metrics['total_time'] = time.time() - start_total_time
            
    except KeyboardInterrupt:
        print("\n[WARNING] Mission interrupted by user!")
        # å¦‚æžœä¸­æ–­ï¼Œä¹Ÿåªè®°å½•åˆ°ä¸­æ–­æ—¶çš„é£žè¡Œæ—¶é—´
        mission_metrics['total_time'] = time.time() - start_total_time
    finally:
        # é™è½æ“ä½œæ”¾åœ¨è®¡æ—¶ç»“æŸåŽæ‰§è¡Œ
        drone_end(uav)

    uav.shutdown()
    rclpy.shutdown()
    
    # ç»ˆæžç¡¬æ ¸æ•°æ®æŠ¥å‘Š
    print("\n==================================================")
    print("ðŸ“ˆ MISSION POST-FLIGHT REPORT (METHOD 2: ULTIMATE)")
    print("==================================================")
    print(f"Algorithm Strategy:  Adaptive Detour (V-Shape + Z-Elevator)")
    print(f"Status:              {'âœ… SUCCESS' if mission_metrics['mission_success'] else 'âŒ FAILED'}")
    print(f"Algorithm Time:      {mission_metrics['algo_time']:.4f} seconds")
    print(f"Net Flight Time:     {mission_metrics['total_time']:.2f} seconds (Excluding Landing)")
    print(f"Flight Distance:     {mission_metrics['planned_distance']:.2f} meters (True Physical Distance)")
    print(f"Path Visited:        START -> {' -> '.join(map(str, mission_metrics['visit_order']))}")
    print("==================================================")
    exit(0)
