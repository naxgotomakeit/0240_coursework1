#!/usr/bin/env python3

# ==============================================================================
# MASTER'S NOTE: Method 2 - Environment-Aware TSP (Visibility Graph Detour)
# Date Authored: 2026-01-06
# Description: This advanced system uses a 3D bounding box vertex heuristic to 
#              generate collision-free detours, calculating true physical distance 
#              before feeding it to the TSP solver.
# ==============================================================================

import argparse
from time import sleep
import time
import yaml
import numpy as np

# å¯¼å…¥ TSP æ±‚è§£å™¨
from python_tsp.heuristics import solve_tsp_local_search
from as2_python_api.drone_interface import DroneInterface
import rclpy

TAKE_OFF_HEIGHT = 1.0  
TAKE_OFF_SPEED = 1.0  
SLEEP_TIME = 0.5  
SPEED = 1.0  
LAND_SPEED = 0.5  

# ==========================================================
# ðŸ§  å¤§è„‘æ¨¡å—ï¼šå‡ ä½•å¯è§†å›¾ä¸ŽçœŸå®žä»£ä»·æŽ¨æ¼”
# ==========================================================

def extract_bounds(obstacles_dict):
    bounds = []
    if not obstacles_dict: return bounds
    for obs_id, obs in obstacles_dict.items():
        half_w, half_d, half_h = obs['w'] / 2.0, obs['d'] / 2.0, obs['h'] / 2.0
        min_b = np.array([obs['x'] - half_w, obs['y'] - half_d, obs['z'] - half_h]) - 0.3
        max_b = np.array([obs['x'] + half_w, obs['y'] + half_d, obs['z'] + half_h]) + 0.3
        bounds.append((min_b, max_b))
    return bounds

def check_collision(p1, p2, obstacle_bounds, num_samples=50):
    if not obstacle_bounds: return False
    t = np.linspace(0, 1, num_samples)[:, np.newaxis] 
    segment_points = p1 + t * (p2 - p1)
    for min_b, max_b in obstacle_bounds:
        inside_x = (segment_points[:, 0] >= min_b[0]) & (segment_points[:, 0] <= max_b[0])
        inside_y = (segment_points[:, 1] >= min_b[1]) & (segment_points[:, 1] <= max_b[1])
        inside_z = (segment_points[:, 2] >= min_b[2]) & (segment_points[:, 2] <= max_b[2])
        if np.any(inside_x & inside_y & inside_z): return True 
    return False

def get_inflated_vertices(obs):
    """èŽ·å–éšœç¢ç‰©è†¨èƒ€ 0.3m åŽçš„ 8 ä¸ªå®‰å…¨é¡¶ç‚¹åæ ‡ (é¿éšœè·³æ¿)"""
    half_w, half_d, half_h = obs['w'] / 2.0, obs['d'] / 2.0, obs['h'] / 2.0
    min_x, max_x = obs['x'] - half_w - 0.3, obs['x'] + half_w + 0.3
    min_y, max_y = obs['y'] - half_d - 0.3, obs['y'] + half_d + 0.3
    min_z, max_z = obs['z'] - half_h - 0.3, obs['z'] + half_h + 0.3
    
    vertices = []
    for x in (min_x, max_x):
        for y in (min_y, max_y):
            for z in (min_z, max_z):
                vertices.append(np.array([x, y, z]))
    return vertices

def calculate_shortest_detour(p1, p2, obstacle_bounds, all_obstacles_dict):
    """è®¡ç®—ä»Ž p1 ç»•è¿‡ç›’å­é¡¶ç‚¹åˆ°è¾¾ p2 çš„æœ€çŸ­æŠ˜çº¿è·ç¦»"""
    best_distance = float('inf')
    best_waypoint = None
    
    if not all_obstacles_dict: 
        return best_distance, best_waypoint
        
    for obs_id, obs in all_obstacles_dict.items():
        vertices = get_inflated_vertices(obs)
        for v in vertices:
            # å‡ ä½•æ£€éªŒï¼šAè¿žåˆ°é¡¶ç‚¹ã€é¡¶ç‚¹è¿žåˆ°Bï¼Œè¿™ä¸¤æ®µçº¿æ˜¯å¦å®‰å…¨ï¼Ÿ
            if not check_collision(p1, v, obstacle_bounds) and \
               not check_collision(v, p2, obstacle_bounds):
                dist = np.linalg.norm(p1 - v) + np.linalg.norm(v - p2)
                if dist < best_distance:
                    best_distance = dist
                    best_waypoint = v
                    
    return best_distance, best_waypoint

def build_cost_matrix(scenario_data):
    """æž„å»ºçœŸå®žçš„ N x N ç‰©ç†ä»£ä»·çŸ©é˜µï¼Œå¹¶è®°å½•é¿éšœè·¯ç‚¹"""
    points = []
    start_pose = scenario_data['drone_start_pose']
    points.append([start_pose['x'], start_pose['y'], start_pose['z']])
    
    vp_poses = scenario_data['viewpoint_poses']
    vp_ids = sorted(vp_poses.keys()) 
    for vp_id in vp_ids:
        vp = vp_poses[vp_id]
        points.append([vp['x'], vp['y'], vp['z']])
        
    points_array = np.array(points)
    N = len(points_array)
    obstacles_dict = scenario_data.get('obstacles', {})
    obstacle_bounds = extract_bounds(obstacles_dict)
    
    cost_matrix = np.zeros((N, N))
    waypoints_matrix = {} # è®°å¿†è¿·å®«ï¼šè®°å½•å“ªä¸¤æ¡è·¯ä¹‹é—´éœ€è¦èµ°å“ªä¸ªç»•è¡Œç‚¹
    
    for i in range(N):
        for j in range(N):
            if i == j: continue
            straight_dist = np.linalg.norm(points_array[i] - points_array[j])
            
            # æ ¸å¿ƒæˆ˜æœ¯è½¬æ¢ï¼šå‘çŽ°éšœç¢ç‰©åŽä¸å†ç›²ç›®æƒ©ç½šï¼Œè€Œæ˜¯å¯»æ‰¾çœŸå®žç»•è·¯ä»£ä»·
            if check_collision(points_array[i], points_array[j], obstacle_bounds):
                detour_dist, waypoint = calculate_shortest_detour(
                    points_array[i], points_array[j], obstacle_bounds, obstacles_dict
                )
                if waypoint is not None:
                    cost_matrix[i][j] = detour_dist
                    waypoints_matrix[(i, j)] = waypoint # è®°ä¸‹å‰§æœ¬
                else:
                    # æžç«¯çš„â€œæ­»èƒ¡åŒâ€ä¿åº•æœºåˆ¶
                    cost_matrix[i][j] = straight_dist * 100.0 
            else:
                cost_matrix[i][j] = straight_dist
                
    return cost_matrix, vp_ids, points_array, waypoints_matrix


# ==========================================================
# ðŸš ç‰©ç†æ‰§è¡Œæ¨¡å—ï¼šæºå¸¦â€œå‰§æœ¬â€çš„æ™ºèƒ½é£žè¡Œ
# ==========================================================

def drone_start(drone_interface: DroneInterface) -> bool:
    print('[LOG] ðŸ›« Start mission sequence...')
    success = drone_interface.arm()
    success = success and drone_interface.offboard()
    success = success and drone_interface.takeoff(height=TAKE_OFF_HEIGHT, speed=TAKE_OFF_SPEED)
    return success

def drone_run(drone_interface: DroneInterface, scenario: dict, metrics: dict) -> bool:
    print('\n[LOG] === ðŸ§  PHASE 1: ENVIRONMENT-AWARE PLANNING ===')
    
    start_algo_time = time.time()
    matrix, original_vp_ids, points_array, waypoints_matrix = build_cost_matrix(scenario)
    route_indices, _ = solve_tsp_local_search(matrix)
    algo_time = time.time() - start_algo_time
    
    planned_distance = 0.0
    optimized_vpids = []

    print(f'[LOG] Algorithm Computation Time: {algo_time:.4f} seconds')
    print('\n[LOG] === ðŸš PHASE 2: TACTICAL EXECUTION ===')
    
    # æ ¹æ®æœ€ä¼˜é¡ºåºï¼Œé€æ®µè§£æžâ€œå‰§æœ¬â€å¹¶é£žè¡Œ
    for step in range(len(route_indices) - 1):
        idx_current = route_indices[step]
        idx_next = route_indices[step + 1]
        
        # æå–ç›®æ ‡ç‚¹çš„ä¿¡æ¯
        vpid = original_vp_ids[idx_next - 1]
        vp = scenario["viewpoint_poses"][vpid]
        optimized_vpids.append(vpid)
        goal = [vp["x"], vp["y"], vp["z"]]
        
        # 1. æ£€æŸ¥å½“å‰èŠ‚ç‚¹åˆ°ç›®æ ‡èŠ‚ç‚¹æ˜¯å¦éœ€è¦â€œç»•å¼¯è·¯â€
        if (idx_current, idx_next) in waypoints_matrix:
            wp = waypoints_matrix[(idx_current, idx_next)]
            planned_distance += np.linalg.norm(points_array[idx_current] - wp)
            planned_distance += np.linalg.norm(wp - points_array[idx_next])
            
            print(f'[LOG] âš ï¸ Obstacle detected! Detouring via geometric vertex: [x={wp[0]:.2f}, y={wp[1]:.2f}, z={wp[2]:.2f}]')
            
            # é£žå‘ä¸­è½¬ç»•è¡Œç‚¹ (Waypoint) - ä¸éœ€è¦æ‚¬åœæ‹ç…§ï¼Œåˆ°äº†å°±èµ°
            success = drone_interface.go_to.go_to_point_with_yaw([float(wp[0]), float(wp[1]), float(wp[2])], angle=vp["w"], speed=SPEED)
            if not success: return False
            
        else:
            planned_distance += np.linalg.norm(points_array[idx_current] - points_array[idx_next])

        # 2. é£žå‘çœŸæ­£çš„ç›®æ ‡è§‚å¯Ÿç‚¹ (Viewpoint)
        print(f'[LOG] >>> Proceeding to Target Viewpoint {vpid} (Pose: x={vp["x"]:.2f}, y={vp["y"]:.2f}, yaw={vp["w"]:.2f})')
        success = drone_interface.go_to.go_to_point_with_yaw(goal, angle=vp["w"], speed=SPEED)
        
        if not success:
            print(f'[ERROR] âŒ Failed to reach Viewpoint {vpid}!')
            return False
            
        print(f'[LOG] âœ… Reached Viewpoint {vpid}. (Simulating Camera Trigger...)')
        sleep(SLEEP_TIME)

    # è®°å½•æœ€ç»ˆæŒ‡æ ‡
    metrics['algo_time'] = algo_time
    metrics['planned_distance'] = planned_distance
    metrics['visit_order'] = optimized_vpids

    return True

def drone_end(drone_interface: DroneInterface) -> bool:
    print('\n[LOG] ðŸ›¬ Ending mission...')
    success = drone_interface.land(speed=LAND_SPEED)
    success = success and drone_interface.manual()
    return success

def read_scenario(file_path):
    with open(file_path, 'r') as file:
        scenario = yaml.safe_load(file)
    return scenario

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Method 2: Environment-Aware TSP')
    parser.add_argument('scenario', type=str, help="scenario file")
    parser.add_argument('-n', '--namespace', type=str, default='drone0')
    parser.add_argument('-v', '--verbose', action='store_true', default=False)
    parser.add_argument('-s', '--use_sim_time', action='store_true', default=True)

    args = parser.parse_args()
    scenario = read_scenario(args.scenario)
    rclpy.init()

    uav = DroneInterface(drone_id=args.namespace, use_sim_time=args.use_sim_time, verbose=args.verbose)
    
    mission_metrics = {'algo_time': 0.0, 'planned_distance': 0.0, 'visit_order': [], 'mission_success': False, 'total_time': 0.0}
    start_total_time = time.time()
    
    success = drone_start(uav)
    try:
        if success:
            flight_success = drone_run(uav, scenario, mission_metrics)
            mission_metrics['mission_success'] = flight_success
    except KeyboardInterrupt:
        print("\n[WARNING] Mission interrupted by user!")
    finally:
        drone_end(uav)
        
    mission_metrics['total_time'] = time.time() - start_total_time

    uav.shutdown()
    rclpy.shutdown()
    
    # ç»ˆæžç¡¬æ ¸æ•°æ®æŠ¥å‘Š
    print("\n==================================================")
    print("ðŸ“ˆ MISSION POST-FLIGHT REPORT (METHOD 2)")
    print("==================================================")
    print(f"Algorithm Strategy:  Geometric Detour + TSP Optimization")
    print(f"Status:              {'âœ… SUCCESS' if mission_metrics['mission_success'] else 'âŒ FAILED'}")
    print(f"Algorithm Time:      {mission_metrics['algo_time']:.4f} seconds")
    print(f"Total Time:          {mission_metrics['total_time']:.2f} seconds")
    print(f"Flight Distance:     {mission_metrics['planned_distance']:.2f} meters (True Physical Distance)")
    print(f"Path Visited:        START -> {' -> '.join(map(str, mission_metrics['visit_order']))}")
    print("==================================================")
    exit(0)
