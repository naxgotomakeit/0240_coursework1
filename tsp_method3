#!/usr/bin/env python3

# ==============================================================================
# Method 2 - Environment-Aware TSP (Visibility Graph Detour + Z-Elevator)
# VERSION 3 FIXES:
#   - Switched to Simulated Annealing TSP solver (escapes local optima)
#   - Vertical penalty in cost matrix (discourages unnecessary climbs)
#   - SAFETY_MARGIN unified to 0.35
#   - Dynamic speed on waypoints based on height delta
#   - Landing excluded from mission time metric
#   - num_samples reduced to 20 for faster planning
# ==============================================================================

import argparse
from time import sleep
import time
import yaml
import numpy as np

from python_tsp.heuristics import solve_tsp_simulated_annealing
from as2_python_api.drone_interface import DroneInterface
import rclpy

# â”€â”€ Flight Parameters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TAKE_OFF_HEIGHT = 1.0
TAKE_OFF_SPEED  = 1.0
SLEEP_TIME      = 0.2   # reduced from 0.5
SPEED           = 1.5   # raised from 1.0
LAND_SPEED      = 0.5

# â”€â”€ Speed Profiles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SPEED_VERTICAL  = SPEED * 0.6   # for climbs / descents
SPEED_LATERAL   = SPEED * 0.8   # for lateral detour corners
SPEED_CRUISE    = SPEED         # for final approach to viewpoint

# â”€â”€ Safety / Planning Parameters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SAFETY_MARGIN      = 0.35   # inflate obstacles on all sides (metres)
VERTICAL_THRESHOLD = 0.8    # height delta above which a leg counts as "vertical"
VERTICAL_PENALTY   = 1.8    # vertical distance costs this many times more than lateral

# â”€â”€ SA Solver Parameters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SA_MAX_TIME   = 10   # seconds of simulated annealing per run
SA_RUNS       = 3    # number of independent restarts (best result is kept)


# ==========================================================================
# ðŸ§   BRAIN MODULE â€” geometry, collision, detour planning
# ==========================================================================

def extract_bounds(obstacles_dict):
    """
    Return AABB bounds for every obstacle, inflated by SAFETY_MARGIN.
    """
    bounds = []
    if not obstacles_dict:
        return bounds
    for obs_id, obs in obstacles_dict.items():
        hw, hd, hh = obs['w'] / 2.0, obs['d'] / 2.0, obs['h'] / 2.0
        min_b = np.array([obs['x'] - hw, obs['y'] - hd, obs['z'] - hh]) - SAFETY_MARGIN
        max_b = np.array([obs['x'] + hw, obs['y'] + hd, obs['z'] + hh]) + SAFETY_MARGIN
        bounds.append((min_b, max_b))
    return bounds


def check_collision(p1, p2, obstacle_bounds, num_samples=20):
    """
    Vectorised segmentâ€“AABB collision check.
    num_samples reduced to 20 for faster planning (sufficient for typical scene scale).
    """
    if not obstacle_bounds:
        return False
    t   = np.linspace(0, 1, num_samples)[:, np.newaxis]
    pts = p1 + t * (p2 - p1)
    for min_b, max_b in obstacle_bounds:
        inside = (
            (pts[:, 0] >= min_b[0]) & (pts[:, 0] <= max_b[0]) &
            (pts[:, 1] >= min_b[1]) & (pts[:, 1] <= max_b[1]) &
            (pts[:, 2] >= min_b[2]) & (pts[:, 2] <= max_b[2])
        )
        if np.any(inside):
            return True
    return False


def weighted_distance(p1, p2):
    """
    Cost metric that penalises vertical travel.
    lateral component  : Euclidean XY distance
    vertical component : |Î”z| Ã— VERTICAL_PENALTY

    This discourages the TSP from picking routes that involve big climbs
    just to visit a distant high point before coming back down.
    """
    lateral  = np.linalg.norm(p1[:2] - p2[:2])
    vertical = abs(p1[2] - p2[2]) * VERTICAL_PENALTY
    return lateral + vertical


def get_inflated_vertices(obs):
    """
    8 corner vertices of the SAFETY_MARGIN-inflated AABB.
    Used as candidate via-points for V-shape detours.
    Must use the same SAFETY_MARGIN as extract_bounds.
    """
    hw, hd, hh = obs['w'] / 2.0, obs['d'] / 2.0, obs['h'] / 2.0
    xs = (obs['x'] - hw - SAFETY_MARGIN, obs['x'] + hw + SAFETY_MARGIN)
    ys = (obs['y'] - hd - SAFETY_MARGIN, obs['y'] + hd + SAFETY_MARGIN)
    zs = (obs['z'] - hh - SAFETY_MARGIN, obs['z'] + hh + SAFETY_MARGIN)
    return [np.array([x, y, z]) for x in xs for y in ys for z in zs]


def calculate_shortest_detour(p1, p2, obstacle_bounds, all_obstacles_dict):
    """
    Two-strategy detour planner (uses weighted_distance for cost so the SA
    solver and the detour planner share the same cost metric).

    Strategy 1 â€“ V-shape lateral detour via obstacle corner vertices.
    Strategy 2 â€“ Z-axis elevator fly-over (fallback for blocked corridors).

    Returns (weighted_detour_cost, list_of_via_points) or (inf, None).
    """
    best_cost      = float('inf')
    best_waypoints = None

    if not all_obstacles_dict:
        return best_cost, best_waypoints

    # â”€â”€ Strategy 1: single-vertex lateral detour â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    for obs in all_obstacles_dict.values():
        for v in get_inflated_vertices(obs):
            if (not check_collision(p1, v, obstacle_bounds) and
                    not check_collision(v, p2, obstacle_bounds)):
                cost = weighted_distance(p1, v) + weighted_distance(v, p2)
                if cost < best_cost:
                    best_cost      = cost
                    best_waypoints = [v]

    # â”€â”€ Strategy 2: Z-elevator fly-over â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if best_waypoints is None:
        max_peak = max(obs['z'] + obs['h'] / 2.0
                       for obs in all_obstacles_dict.values())
        safe_z  = max_peak + SAFETY_MARGIN

        wp_up   = np.array([p1[0], p1[1], safe_z])
        wp_over = np.array([p2[0], p2[1], safe_z])

        if (not check_collision(p1,    wp_up,   obstacle_bounds) and
                not check_collision(wp_up,  wp_over, obstacle_bounds) and
                not check_collision(wp_over, p2,     obstacle_bounds)):

            cost = (weighted_distance(p1,    wp_up) +
                    weighted_distance(wp_up,  wp_over) +
                    weighted_distance(wp_over, p2))
            best_cost      = cost
            best_waypoints = [wp_up, wp_over]

    return best_cost, best_waypoints


def build_cost_matrix(scenario_data):
    """
    Build NÃ—N cost matrix using weighted_distance so the TSP solver
    naturally prefers routes that minimise unnecessary altitude changes.

    Also returns waypoints_matrix: dict[(i,j)] â†’ [via_point, ...]
    """
    points = []
    start  = scenario_data['drone_start_pose']
    points.append([start['x'], start['y'], start['z']])

    vp_poses = scenario_data['viewpoint_poses']
    vp_ids   = sorted(vp_poses.keys())
    for vpid in vp_ids:
        vp = vp_poses[vpid]
        points.append([vp['x'], vp['y'], vp['z']])

    points_array    = np.array(points)
    N               = len(points_array)
    obstacles_dict  = scenario_data.get('obstacles', {})
    obstacle_bounds = extract_bounds(obstacles_dict)

    cost_matrix      = np.zeros((N, N))
    waypoints_matrix = {}

    for i in range(N):
        for j in range(N):
            if i == j:
                continue
            p1, p2 = points_array[i], points_array[j]

            if check_collision(p1, p2, obstacle_bounds):
                detour_cost, wp_list = calculate_shortest_detour(
                    p1, p2, obstacle_bounds, obstacles_dict
                )
                if wp_list is not None:
                    cost_matrix[i][j]        = detour_cost
                    waypoints_matrix[(i, j)] = wp_list
                else:
                    # No detour found â€” heavy penalty so TSP avoids this edge
                    cost_matrix[i][j] = weighted_distance(p1, p2) * 100.0
            else:
                cost_matrix[i][j] = weighted_distance(p1, p2)

    return cost_matrix, vp_ids, points_array, waypoints_matrix


def solve_tsp_best_of(matrix):
    """
    Run Simulated Annealing SA_RUNS times and return the best route found.
    Multiple restarts help escape local optima that single-run local search misses.
    """
    best_route, best_cost = None, float('inf')
    for run in range(SA_RUNS):
        route, cost = solve_tsp_simulated_annealing(
            matrix, max_processing_time=SA_MAX_TIME
        )
        print(f'[LOG]   SA run {run + 1}/{SA_RUNS}  cost={cost:.2f}  route={route}')
        if cost < best_cost:
            best_cost  = cost
            best_route = route
    return best_route, best_cost


# ==========================================================================
# ðŸš  EXECUTION MODULE â€” drone control
# ==========================================================================

def _exec_speed(from_pos, to_pos):
    """Choose speed based on height delta of the leg."""
    if abs(float(to_pos[2]) - float(from_pos[2])) > VERTICAL_THRESHOLD:
        return SPEED_VERTICAL
    return SPEED_LATERAL


def drone_start(drone_interface: DroneInterface) -> bool:
    print('[LOG] ðŸ›«  Arming and taking off...')
    ok = drone_interface.arm()
    ok = ok and drone_interface.offboard()
    ok = ok and drone_interface.takeoff(height=TAKE_OFF_HEIGHT, speed=TAKE_OFF_SPEED)
    print(f'[LOG] Take-off: {"âœ… OK" if ok else "âŒ FAILED"}')
    return ok


def drone_run(drone_interface: DroneInterface, scenario: dict, metrics: dict) -> bool:
    print('\n[LOG] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
    print('[LOG] ðŸ§   PHASE 1 â€” ENVIRONMENT-AWARE PATH PLANNING')
    print(f'[LOG]     SafetyMargin={SAFETY_MARGIN}m  '
          f'VerticalPenalty={VERTICAL_PENALTY}x  '
          f'SA runs={SA_RUNS}Ã—{SA_MAX_TIME}s')
    print('[LOG] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')

    t0 = time.time()
    matrix, original_vp_ids, points_array, waypoints_matrix = build_cost_matrix(scenario)
    route_indices, best_cost = solve_tsp_best_of(matrix)
    algo_time = time.time() - t0

    print(f'[LOG] Planning time : {algo_time:.4f} s')
    print(f'[LOG] Best TSP cost : {best_cost:.2f}')
    print(f'[LOG] Route indices : {route_indices}')

    print('\n[LOG] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
    print('[LOG] ðŸš  PHASE 2 â€” TACTICAL EXECUTION')
    print('[LOG] â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')

    planned_distance = 0.0
    optimized_vpids  = []

    for step in range(len(route_indices) - 1):
        idx_curr = route_indices[step]
        idx_next = route_indices[step + 1]

        if idx_next == 0:
            continue  # open-path mission, skip return-to-start edge

        vpid = original_vp_ids[idx_next - 1]
        vp   = scenario['viewpoint_poses'][vpid]
        goal = [float(vp['x']), float(vp['y']), float(vp['z'])]
        optimized_vpids.append(vpid)

        current_pos = points_array[idx_curr]

        # â”€â”€ Intermediate via-points (detour or elevator) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (idx_curr, idx_next) in waypoints_matrix:
            for wp in waypoints_matrix[(idx_curr, idx_next)]:
                wp_f = [float(wp[0]), float(wp[1]), float(wp[2])]
                spd  = _exec_speed(current_pos, wp)

                print(f'[LOG] âš ï¸  Via-point [{wp_f[0]:.2f}, {wp_f[1]:.2f}, {wp_f[2]:.2f}]'
                      f'  speed={spd:.2f}')

                ok = drone_interface.go_to.go_to_point_with_yaw(
                    wp_f, angle=float(vp['w']), speed=spd
                )
                if not ok:
                    print(f'[ERROR] âŒ Failed at via-point for VP {vpid}')
                    return False

                planned_distance += np.linalg.norm(current_pos - wp)
                current_pos = wp

        planned_distance += np.linalg.norm(current_pos - points_array[idx_next])

        # â”€â”€ Final approach to viewpoint â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        print(f'[LOG] >>> VP {vpid}  '
              f'(x={vp["x"]:.2f}  y={vp["y"]:.2f}  z={vp["z"]:.2f}  yaw={vp["w"]:.2f})'
              f'  speed={SPEED_CRUISE:.2f}')

        ok = drone_interface.go_to.go_to_point_with_yaw(
            goal, angle=float(vp['w']), speed=SPEED_CRUISE
        )
        if not ok:
            print(f'[ERROR] âŒ Failed to reach Viewpoint {vpid}!')
            return False

        print(f'[LOG] âœ…  Reached VP {vpid}.')
        sleep(SLEEP_TIME)

    metrics['algo_time']       = algo_time
    metrics['planned_distance'] = planned_distance
    metrics['visit_order']     = optimized_vpids
    return True


def drone_end(drone_interface: DroneInterface) -> bool:
    """Land â€” called AFTER the mission timer has stopped."""
    print('\n[LOG] ðŸ›¬  Landing (NOT counted in mission time)...')
    ok = drone_interface.land(speed=LAND_SPEED)
    ok = ok and drone_interface.manual()
    print(f'[LOG] Land: {"âœ… OK" if ok else "âŒ FAILED"}')
    return ok


def read_scenario(file_path: str) -> dict:
    with open(file_path, 'r') as f:
        return yaml.safe_load(f)


# ==========================================================================
# ðŸ“Š  ENTRY POINT & POST-FLIGHT REPORT
# ==========================================================================

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Method 2 v3 â€“ SA-TSP + Vertical Penalty + Dynamic Speed')
    parser.add_argument('scenario',             type=str,            help='Path to scenario YAML')
    parser.add_argument('-n', '--namespace',    type=str, default='drone0')
    parser.add_argument('-v', '--verbose',      action='store_true', default=False)
    parser.add_argument('-s', '--use_sim_time', action='store_true', default=True)
    args = parser.parse_args()

    print('=' * 56)
    print('ðŸš€  METHOD 2 v3 â€” SA-TSP + VERTICAL PENALTY')
    print(f'    Scenario      : {args.scenario}')
    print(f'    Drone ID      : {args.namespace}')
    print(f'    SPEED         : {SPEED} m/s')
    print(f'    SafetyMargin  : {SAFETY_MARGIN} m')
    print(f'    VertPenalty   : {VERTICAL_PENALTY}Ã—')
    print(f'    SA runs       : {SA_RUNS} Ã— {SA_MAX_TIME}s')
    print('=' * 56)

    scenario = read_scenario(args.scenario)
    rclpy.init()

    uav = DroneInterface(
        drone_id=args.namespace,
        use_sim_time=args.use_sim_time,
        verbose=args.verbose
    )

    mission_metrics = {
        'algo_time':        0.0,
        'planned_distance': 0.0,
        'visit_order':      [],
        'mission_success':  False,
        'total_time':       0.0,
    }

    t_mission_start = time.time()
    success = drone_start(uav)

    try:
        if success:
            flight_ok = drone_run(uav, scenario, mission_metrics)
            mission_metrics['mission_success'] = flight_ok

        # â•â• STOP CLOCK HERE â€” before landing â•â•
        mission_metrics['total_time'] = time.time() - t_mission_start

    except KeyboardInterrupt:
        mission_metrics['total_time'] = time.time() - t_mission_start
        print('\n[WARNING] Mission interrupted by user.')

    finally:
        drone_end(uav)  # landing after timing

    uav.shutdown()
    rclpy.shutdown()

    # â”€â”€ Post-flight report â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print('\n' + '=' * 56)
    print('ðŸ“ˆ  POST-FLIGHT REPORT  (METHOD 2 v3)')
    print('=' * 56)
    print(f"Strategy         : SA-TSP + V-Shape/Z-Elevator Detour")
    print(f"Safety Margin    : {SAFETY_MARGIN} m")
    print(f"Vertical Penalty : {VERTICAL_PENALTY}Ã—")
    print(f"Status           : {'âœ… SUCCESS' if mission_metrics['mission_success'] else 'âŒ FAILED'}")
    print(f"Algorithm Time   : {mission_metrics['algo_time']:.4f} s  (inc. SA planning)")
    print(f"Net Mission Time : {mission_metrics['total_time']:.2f} s  (landing excluded)")
    print(f"Flight Distance  : {mission_metrics['planned_distance']:.2f} m  (true physical)")
    print(f"Path Visited     : START -> {' -> '.join(map(str, mission_metrics['visit_order']))}")
    print('=' * 56)
    exit(0)
